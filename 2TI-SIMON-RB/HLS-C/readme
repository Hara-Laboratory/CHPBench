In the development of this design, coding in Verilog kicked in since the original author did not share a top-module for their RTL design, therefore we need to build a RTL top-module before we can move to translating RTL design to C++ design. With the reference of the other two SIMONs' top-level designs, since they all hold exact same IO, a rough draft of top-module can be easily made, however designing specific control logic for the round-based SIMON core is very tricky- unlike bit-serialized SIMON core which runs $68 \text{ rounds} * 64 \text{ cycles/round} = 4352 \text{ cycles}$ during encryption stage, round-based SIMON core process one round of operation in one cycle, resulting a much higher core resource consumption but also much higher throughput since latency is tremendously reduced comparing to bit-serialized SIMON core design. Fortunately the author provided the testbench for round-based SIMON core so we can build the control logic based on when in the testbench the state (of a finite state machine) is modified, and on which cycle stop inputing data. A customized top-module for RTL design is then built successfully, which soon turns into C++ design.

During the C++ translation of TI2-SIMON-Round-Based, we changed the coding style slightly, and implement all module classes inside one single file including the top-level function. In this way, no more header files need to be created for the whole design to be able to compile, instead since all classes and functions are declared in one single file, the header is only needed when running C-Simulation for debugging purposes, this slightly reduces the workload of initial build and effort needed for code management. Following Table 4.3 shows the final implementation result of the HLS-generated design comparing to the original RTL design. 
